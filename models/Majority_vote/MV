import sys
from torchvision.transforms import v2
import pandas as pd
import torch
import utils.dataloader as dataloader
import numpy as np

sys.path.append("../..")

from SOM.SOM import SOM
from VAE.VAE import VAE

from utils.load_save_models import load_model
from preprocessing import tiff_handling


class Majority_Vote:
    som_input_dim = 100
    som_map_dim = 80

    som_transform = v2.Compose(
        [
            v2.ToImage(),
            v2.ToDtype(torch.float32, scale=True),
            v2.Resize((60, 80)),
            # v2.Lambda(
            #     lambda x: (x.view(-1) - torch.min(x)) / (torch.max(x) - torch.min(x))
            # ),
        ]
    )

    vae_batch_size = 436
    vae_input_dim = 4800
    vae_hidden_dim = 4000
    vae_latent_dim = 320

    vae_transform = v2.Compose(
        [
            v2.ToImage(),
            v2.ToDtype(torch.float32, scale=True),
            v2.Resize((60, 80)),
            v2.ToTensor(),
            v2.Lambda(
                lambda x: (x.view(-1) - torch.min(x)) / (torch.max(x) - torch.min(x))
            ),
        ]
    )

    def __init__(self):
        # SOM

        self.som = SOM.load_model(
            SOM(self.som_input_dim, self.som_map_dim), "models/SOM/hpc_SOM_model.pkl"
        )

        # VAE

        vae = VAE(self.vae_input_dim, self.vae_hidden_dim, self.vae_latent_dim)

        self.vae = load_model(vae, "models/VAE/hpc_VAE_model.pkl", True)

        # CNN

    def set_thresholds(self, val_set: pd.DataFrame):
        vae_val_set = dataloader.ImagePathDataset(val_set, self.vae_transform)

        som_val_set = np.array(
            [
                tiff_handling.flatten_image(
                    self.som_transform(tiff_handling.handle_tiff(el))
                )
                for el in val_set["file_names"].tolist()
            ]
        )

        val_dataloader = torch.utils.data.DataLoader(
            vae_val_set, batch_size=self.vae_batch_size, shuffle=True
        )

        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.vae.to(device)

        self.vae.extract_error_threshold(val_dataloader, method="percentile", value=85)

        self.som.set_threshold(som_val_set, percentile=90)

    def predict(self, test_set: pd.DataFrame):
        som_test = test_set
        som_test["image"] = som_test["file_names"].apply(
            lambda x: tiff_handling.flatten_image(
                self.som_transform(tiff_handling.handle_tiff(x))
            )
        )

        vae_test = test_set
        vae_test["image"] = vae_test["file_names"].apply(
            lambda x: self.vae_transform(tiff_handling.handle_tiff(x))
        )

        som_output = self.som.predict(som_test)
        vae_output = self.vae.predict(vae_test)

        # TODO add CNN prediction and compute eventual prediction
